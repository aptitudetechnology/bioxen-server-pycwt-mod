# BioXen Wishful API Specification v0.1.0 🔮

**Server Name:** BioXen Computation Services  
**Base URL:** `http://bioxen.local:8000`  
**API Version:** v1  
**Status:** Specification (Aspirational - Phase 6+)  
**Date:** October 5, 2025

---

## 📋 Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Authentication](#authentication)
4. [Common Patterns](#common-patterns)
5. [Signal Analysis APIs](#signal-analysis-apis)
6. [Model Validation APIs](#model-validation-apis)
7. [Parameter Tuning APIs](#parameter-tuning-apis)
8. [Sensor Hardware APIs](#sensor-hardware-apis)
9. [Error Handling](#error-handling)
10. [Rate Limiting](#rate-limiting)
11. [Implementation Guide](#implementation-guide)

---

## 📖 Overview

### Purpose

The BioXen Wishful API provides **remote computation services** for biological signal analysis, model validation, and parameter optimization. This API wraps existing BioXen functionality (SystemAnalyzer, BioValidator) in REST endpoints.

**Key Principle:** The server provides **stateless computation services**. VM management and simulation execution remain local to the BioXen library.

### What This API Does

✅ **Heavy Computation:**
- Fourier/Wavelet/Laplace/Z-Transform analysis
- Multi-domain signal analysis
- Oscillation period detection
- Stability classification

✅ **Validation Services:**
- Oscillation validation (period, amplitude, phase)
- Numerical stability checking
- Quality scoring
- Deviation detection

✅ **Optimization Services:**
- Rate constant tuning
- Parameter sweeps
- Sensitivity analysis
- Timestep optimization

✅ **Hardware Integration:**
- Environmental sensor readings (BME280, LTR-559)
- Sensor calibration
- Real-time monitoring

### What This API Does NOT Do

❌ **VM Management:** Creating, starting, stopping VMs (handled locally)  
❌ **Simulation Execution:** Running biological simulations (local)  
❌ **State Management:** VM state, resource allocation (local)  
❌ **Data Storage:** Long-term storage of results (client's responsibility)

### Service Model

```
┌─────────────────┐                    ┌─────────────────┐
│  BioXen Local   │                    │  BioXen Server  │
│   (Client)      │                    │  (Computation)  │
├─────────────────┤                    ├─────────────────┤
│ • VM Management │  ──── HTTP ───>    │ • Fourier       │
│ • Simulation    │  <─── JSON ────    │ • Wavelet       │
│ • Time-series   │                    │ • Laplace       │
│   generation    │                    │ • Z-Transform   │
│ • Results       │                    │ • Validation    │
│   storage       │                    │ • Optimization  │
└─────────────────┘                    └─────────────────┘
```

---

## 🏗️ Architecture

### Technology Stack

**Server Framework:** FastAPI 0.104+  
**Scientific Computing:** NumPy 1.24+, SciPy 1.11+, Astropy 5.3+  
**Wavelet Analysis:** PyWavelets 1.4+  
note: We developed a API sever version (forked) from pycwt as pycwt-mod with a modular plug-in arcitecture. Please see:

https://github.com/aptitudetechnology/pycwt-mod

**Optimization:** scipy.optimize, SALib, scikit-optimize  
**Hardware:** smbus2, pimoroni-bme280, ltr559  
**Documentation:** OpenAPI 3.1 (auto-generated by FastAPI)

### Deployment

```
┌─────────────────────────────────────────────────────────┐
│                    BioXen Server                        │
├─────────────────────────────────────────────────────────┤
│  FastAPI App                                            │
│    ├─ /api/v1/analysis/*    (Analysis endpoints)       │
│    ├─ /api/v1/validate/*    (Validation endpoints)     │
│    ├─ /api/v1/tune/*        (Optimization endpoints)   │
│    └─ /api/v1/sensors/*     (Hardware endpoints)       │
├─────────────────────────────────────────────────────────┤
│  Core Libraries                                         │
│    ├─ SystemAnalyzer        (from BioXen)              │
│    ├─ OscillationValidator  (new wrapper)              │
│    ├─ ParameterTuner        (new optimization)         │
│    └─ SensorManager         (new hardware)             │
└─────────────────────────────────────────────────────────┘
```

### Performance Requirements

- **Response Time:** <200ms for analysis, <500ms for optimization
- **Throughput:** 100+ requests/second
- **Memory:** <2GB per worker process
- **Concurrency:** Async support for I/O-bound operations

---

## 🔐 Authentication

### Phase 1: No Authentication (Development)

For initial development and testing:
- No authentication required
- Local network only (bioxen.local)
- Trust-based access

### Phase 2: API Key Authentication (Production)

```http
GET /api/v1/analysis/fourier HTTP/1.1
Host: bioxen.local:8000
X-API-Key: your-api-key-here
Content-Type: application/json
```

**Header:** `X-API-Key: <api-key>`  
**Key Format:** UUID v4 (e.g., `550e8400-e29b-41d4-a716-446655440000`)  
**Key Management:** Store in environment variable or config file

---

## 🔄 Common Patterns

### Request/Response Format

All requests and responses use **JSON**.

**Standard Request:**
```json
{
  "timestamps": [0.0, 1.0, 2.0, 3.0, ...],
  "values": [1.0, 1.1, 0.9, 1.05, ...],
  "metadata": {
    "organism": "ecoli",
    "experiment_id": "exp_20251005_001"
  }
}
```

**Standard Response:**
```json
{
  "result": { ... },
  "metadata": {
    "computation_time_ms": 45,
    "server_version": "0.1.0",
    "timestamp": "2025-10-05T10:30:00Z"
  }
}
```

### Time Series Format

All time-series data follows this convention:

- **timestamps:** Array of floats (seconds since start, or Unix time)
- **values:** Array of floats (same length as timestamps)
- **Optional fields:** `sampling_rate`, `units`, `organism`

### Biological Context

Many endpoints support organism-specific constraints:

```json
{
  "organism": "ecoli",      // ecoli, yeast, cyanobacteria, neurospora
  "temperature": 37.0,       // Celsius
  "ph": 7.0,                 // pH
  "growth_phase": "log"      // lag, log, stationary, death
}
```

---

## 📊 Signal Analysis APIs

### Base Path: `/api/v1/analysis`

---

### 1. Fourier Analysis

**Endpoint:** `POST /api/v1/analysis/fourier`

**Description:** Perform frequency-domain analysis using Lomb-Scargle periodogram (handles irregular sampling). Detects dominant frequencies, harmonics, and circadian rhythms.

**Implementation:** Wraps `SystemAnalyzer.fourier_lens()`

**Request Body:**
```json
{
  "timestamps": [0.0, 1.0, 2.0, ...],        // Required: time points (seconds)
  "values": [1.0, 1.1, 0.9, ...],            // Required: signal values
  "method": "fft",                            // Optional: "fft" | "lombscargle" (default: "fft")
  "detect_peaks": true,                       // Optional: detect dominant periods (default: false)
  "detect_harmonics": true,                   // Optional: detect multiple harmonics (default: false)
  "max_harmonics": 5,                         // Optional: max harmonics to detect (default: 5)
  "min_period_hours": 1.0,                    // Optional: minimum period to detect (hours)
  "max_period_hours": 100.0                   // Optional: maximum period to detect (hours)
}
```

**Response (200 OK):**
```json
{
  "frequencies": [0.001, 0.002, 0.003, ...],  // Hz
  "magnitudes": [10.5, 8.3, 15.2, ...],       // Power spectrum
  "phases": [0.0, 1.57, 3.14, ...],           // Phase angles (radians)
  "dominant_frequency": 0.0417,                // Hz (~24 hour period)
  "dominant_period": 24.0,                     // Hours
  "significance": 0.95,                        // Confidence (0-1)
  "harmonics": [                               // If detect_harmonics=true
    {
      "frequency": 0.0417,                     // Hz
      "period": 24.0,                          // Hours
      "power": 15.2,
      "amplitude": 3.9,
      "phase": 0.0
    },
    {
      "frequency": 0.0833,                     // 2nd harmonic (12h)
      "period": 12.0,
      "power": 5.1,
      "amplitude": 1.4,
      "phase": 1.57
    }
  ],
  "metadata": {
    "computation_time_ms": 45,
    "num_samples": 576,
    "sampling_rate_hz": 0.2,
    "nyquist_frequency_hz": 0.1
  }
}
```

**Example Usage:**
```python
import httpx

response = httpx.post(
    "http://bioxen.local:8000/api/v1/analysis/fourier",
    json={
        "timestamps": [0, 3600, 7200, 10800, ...],  # Every hour for 48h
        "values": [100, 105, 98, 110, ...],          # ATP levels
        "detect_peaks": True,
        "detect_harmonics": True
    }
)

data = response.json()
print(f"Circadian period detected: {data['dominant_period']:.1f} hours")
```

**Error Responses:**
- `400 Bad Request` - Invalid input (empty arrays, mismatched lengths)
- `422 Unprocessable Entity` - Validation error (negative dt, invalid method)
- `500 Internal Server Error` - Computation error

---

### 2. Wavelet Analysis

**Endpoint:** `POST /api/v1/analysis/wavelet`

**Description:** Continuous Wavelet Transform (CWT) for time-frequency analysis. Detects transient events, localized changes, and non-stationary dynamics.

**Implementation:** Wraps `SystemAnalyzer.wavelet_lens()`

**Request Body:**
```json
{
  "timestamps": [0.0, 1.0, 2.0, ...],        // Required: time points
  "values": [1.0, 1.1, 0.9, ...],            // Required: signal values
  "wavelet_type": "morlet",                   // Optional: "morlet" | "paul" | "dog" (default: "morlet")
  "scales": [1, 2, 3, ..., 100],             // Optional: wavelet scales (default: auto)
  "detect_transients": true,                  // Optional: detect sudden changes (default: false)
  "transient_threshold": 2.0                  // Optional: threshold in std devs (default: 2.0)
}
```

**Response (200 OK):**
```json
{
  "scales": [1, 2, 3, ..., 100],
  "frequencies": [0.5, 0.25, 0.167, ...],    // Pseudo-frequencies (Hz)
  "coefficients": [                           // Complex CWT coefficients [scales x time]
    [1.2, 1.5, 1.1, ...],                    // Scale 1
    [0.8, 0.9, 0.7, ...],                    // Scale 2
    ...
  ],
  "power": [                                  // Absolute values (power map)
    [1.44, 2.25, 1.21, ...],
    [0.64, 0.81, 0.49, ...],
    ...
  ],
  "wavelet_used": "morlet",
  "transients_detected": [                    // If detect_transients=true
    {
      "time": 3600.0,                        // Seconds
      "scale": 10,
      "power": 5.2,
      "type": "sudden_increase"
    },
    {
      "time": 7200.0,
      "scale": 15,
      "power": 4.8,
      "type": "sudden_decrease"
    }
  ],
  "metadata": {
    "computation_time_ms": 120,
    "num_scales": 100,
    "num_samples": 576
  }
}
```

**Example Usage:**
```python
response = httpx.post(
    "http://bioxen.local:8000/api/v1/analysis/wavelet",
    json={
        "timestamps": timestamps,
        "values": atp_levels,
        "wavelet_type": "morlet",
        "detect_transients": True
    }
)

data = response.json()
print(f"Detected {len(data['transients_detected'])} stress responses")
```

---

### 3. Laplace Analysis

**Endpoint:** `POST /api/v1/analysis/laplace`

**Description:** System stability analysis via pole-zero analysis. Classifies system as stable, oscillatory, or unstable based on pole locations.

**Implementation:** Wraps `SystemAnalyzer.laplace_lens()`

**Request Body:**
```json
{
  "timestamps": [0.0, 1.0, 2.0, ...],
  "values": [1.0, 1.1, 0.9, ...],
  "check_stability": true                     // Optional: perform stability check (default: true)
}
```

**Response (200 OK):**
```json
{
  "poles": [
    {"real": -0.1, "imaginary": 0.0},
    {"real": -0.05, "imaginary": 0.26},      // Complex conjugate pair
    {"real": -0.05, "imaginary": -0.26}
  ],
  "zeros": [
    {"real": 0.0, "imaginary": 0.0}
  ],
  "stability": "stable",                      // "stable" | "oscillatory" | "unstable"
  "stable": true,                             // Boolean for quick check
  "natural_frequency": 0.267,                 // Hz (from dominant poles)
  "damping_ratio": 0.15,                      // Damping coefficient
  "time_constant": 20.0,                      // Seconds (1/|real part|)
  "metadata": {
    "computation_time_ms": 35,
    "num_poles": 3,
    "classification": "underdamped_oscillator"
  }
}
```

**Stability Classification:**
- **stable:** All poles have negative real parts (system returns to equilibrium)
- **oscillatory:** Poles near imaginary axis (sustained oscillations)
- **unstable:** Any pole has positive real part (exponential growth)

**Example Usage:**
```python
response = httpx.post(
    "http://bioxen.local:8000/api/v1/analysis/laplace",
    json={
        "timestamps": timestamps,
        "values": metabolite_levels,
        "check_stability": True
    }
)

data = response.json()
if data['stable']:
    print(f"System stable with damping ratio {data['damping_ratio']:.2f}")
else:
    print("WARNING: System unstable!")
```

---

### 4. Z-Transform Analysis

**Endpoint:** `POST /api/v1/analysis/ztransform`

**Description:** Digital filter design and discrete-time analysis. Apply Butterworth filters to remove noise.

**Implementation:** Wraps `SystemAnalyzer.z_transform_lens()`

**Request Body:**
```json
{
  "timestamps": [0.0, 1.0, 2.0, ...],
  "values": [1.0, 1.1, 0.9, ...],
  "cutoff_frequency": 0.1,                    // Optional: cutoff freq in Hz (default: auto)
  "filter_order": 4,                          // Optional: filter order (default: 4)
  "filter_type": "lowpass"                    // Optional: "lowpass" | "highpass" (default: "lowpass")
}
```

**Response (200 OK):**
```json
{
  "filtered_signal": [1.0, 1.08, 0.95, ...],
  "noise_reduction_percent": 35.2,
  "cutoff_frequency": 0.1,
  "filter_coefficients": {
    "b": [0.1, 0.2, 0.3, 0.2, 0.1],          // Numerator
    "a": [1.0, -0.5, 0.3, -0.1, 0.05]        // Denominator
  },
  "z_poles": [
    {"real": 0.8, "imaginary": 0.1},
    {"real": 0.8, "imaginary": -0.1}
  ],
  "stable": true,                             // All poles inside unit circle
  "metadata": {
    "computation_time_ms": 25,
    "filter_order": 4,
    "original_snr": 10.5,
    "filtered_snr": 18.3
  }
}
```

---

### 5. Multi-Domain Analysis

**Endpoint:** `POST /api/v1/analysis/multi-domain`

**Description:** Apply all four lenses (Fourier, Wavelet, Laplace, Z-Transform) in one request. Returns comprehensive "four-lens" analysis.

**Request Body:**
```json
{
  "timestamps": [0.0, 1.0, 2.0, ...],
  "values": [1.0, 1.1, 0.9, ...],
  "analyses": ["fourier", "wavelet", "laplace", "ztransform"],  // Which lenses to apply
  "detect_harmonics": true,
  "detect_transients": true
}
```

**Response (200 OK):**
```json
{
  "fourier": { /* Fourier result */ },
  "wavelet": { /* Wavelet result */ },
  "laplace": { /* Laplace result */ },
  "ztransform": { /* Z-Transform result */ },
  "summary": {
    "dominant_period_hours": 24.0,
    "system_stability": "stable",
    "transient_events_detected": 3,
    "noise_level_percent": 12.5
  },
  "metadata": {
    "computation_time_ms": 220,
    "analyses_performed": 4
  }
}
```

---

## ✅ Model Validation APIs

### Base Path: `/api/v1/validate`

---

### 6. Oscillation Validation

**Endpoint:** `POST /api/v1/validate/oscillation`

**Description:** Validate oscillation period against expected value with tolerance checking. Returns validation result and deviation metrics.

**Request Body:**
```json
{
  "timestamps": [0.0, 1.0, 2.0, ...],
  "values": [1.0, 1.1, 0.9, ...],
  "expected_period_hours": 24.0,              // Expected circadian period
  "tolerance_hours": 2.0,                     // Acceptable deviation
  "min_amplitude": 0.1,                       // Optional: minimum amplitude
  "require_significance": 0.9                 // Optional: min significance (default: 0.8)
}
```

**Response (200 OK):**
```json
{
  "validation_passed": true,
  "measured_period_hours": 24.3,
  "deviation_hours": 0.3,
  "amplitude": 3.5,
  "significance": 0.95,
  "quality_score": 0.88,                      // 0-1 scale
  "details": {
    "within_tolerance": true,
    "amplitude_sufficient": true,
    "significance_met": true,
    "harmonics_detected": 2
  },
  "metadata": {
    "computation_time_ms": 50
  }
}
```

**Example Usage:**
```python
response = httpx.post(
    "http://bioxen.local:8000/api/v1/validate/oscillation",
    json={
        "timestamps": timestamps,
        "values": gene_expression_levels,
        "expected_period_hours": 24.0,
        "tolerance_hours": 2.0,
        "organism": "cyanobacteria"
    }
)

data = response.json()
if data['validation_passed']:
    print(f"✅ Circadian rhythm validated: {data['measured_period_hours']:.1f}h")
else:
    print(f"❌ Validation failed: deviation of {data['deviation_hours']:.1f}h")
```

---

### 7. Amplitude Validation

**Endpoint:** `POST /api/v1/validate/amplitude`

**Description:** Detect amplitude decay over time. Useful for checking if oscillations remain stable or are damping out.

**Request Body:**
```json
{
  "timestamps": [0.0, 1.0, 2.0, ...],
  "values": [1.0, 1.1, 0.9, ...],
  "max_decay_percent": 10.0,                  // Maximum allowed amplitude decay
  "window_size_hours": 24.0                   // Window for measuring amplitude
}
```

**Response (200 OK):**
```json
{
  "validation_passed": true,
  "decay_detected": false,
  "decay_percent": 3.2,                       // Measured decay
  "initial_amplitude": 3.5,
  "final_amplitude": 3.39,
  "decay_rate_per_hour": 0.00133,
  "metadata": {
    "computation_time_ms": 30,
    "num_windows_analyzed": 2
  }
}
```

---

### 8. Stability Validation

**Endpoint:** `POST /api/v1/validate/stability`

**Description:** Check numerical stability using Laplace pole analysis. Ensures system is not diverging or exhibiting chaotic behavior.

**Request Body:**
```json
{
  "timestamps": [0.0, 1.0, 2.0, ...],
  "values": [1.0, 1.1, 0.9, ...],
  "max_real_pole": 0.0,                       // Maximum allowed real part (default: 0.0)
  "check_oscillatory": true                    // Flag if oscillatory behavior is OK
}
```

**Response (200 OK):**
```json
{
  "validation_passed": true,
  "stable": true,
  "stability_classification": "stable",
  "max_pole_real_part": -0.1,
  "damping_ratio": 0.15,
  "all_poles_stable": true,
  "poles": [
    {"real": -0.1, "imaginary": 0.0},
    {"real": -0.05, "imaginary": 0.26}
  ],
  "metadata": {
    "computation_time_ms": 35
  }
}
```

---

### 9. Deviation Detection

**Endpoint:** `POST /api/v1/validate/deviation`

**Description:** Detect period drift, phase drift, or amplitude changes over time. Compares different time windows to identify trends.

**Request Body:**
```json
{
  "timestamps": [0.0, 1.0, 2.0, ...],
  "values": [1.0, 1.1, 0.9, ...],
  "detection_type": "period_drift",           // "period_drift" | "phase_drift" | "amplitude_decay"
  "window_size_hours": 24.0,
  "max_drift_percent": 5.0
}
```

**Response (200 OK):**
```json
{
  "validation_passed": true,
  "drift_detected": false,
  "drift_percent": 2.1,
  "windows_analyzed": [
    {
      "start_time": 0.0,
      "end_time": 86400.0,
      "period": 24.1
    },
    {
      "start_time": 86400.0,
      "end_time": 172800.0,
      "period": 24.3
    }
  ],
  "trend": "increasing",                      // "increasing" | "decreasing" | "stable"
  "metadata": {
    "computation_time_ms": 80
  }
}
```

---

### 10. Quality Scoring

**Endpoint:** `POST /api/v1/validate/quality`

**Description:** Calculate overall quality score for time-series data. Combines multiple metrics (SNR, significance, regularity).

**Request Body:**
```json
{
  "timestamps": [0.0, 1.0, 2.0, ...],
  "values": [1.0, 1.1, 0.9, ...],
  "expected_behavior": "circadian"            // Optional: "circadian" | "stable" | "growing"
}
```

**Response (200 OK):**
```json
{
  "quality_score": 0.88,                      // 0-1 scale
  "components": {
    "signal_to_noise": 0.92,
    "periodicity_score": 0.85,
    "stability_score": 0.90,
    "regularity_score": 0.85
  },
  "grade": "A",                               // A, B, C, D, F
  "issues": [],                               // Empty if no issues
  "recommendations": [
    "Consider longer sampling period for better frequency resolution"
  ],
  "metadata": {
    "computation_time_ms": 60
  }
}
```

---

### 11. Batch Validation

**Endpoint:** `POST /api/v1/validate/batch`

**Description:** Validate multiple time-series in one request. Useful for comparing multiple genes or metabolites.

**Request Body:**
```json
{
  "signals": [
    {
      "id": "gene_a",
      "timestamps": [0.0, 1.0, 2.0, ...],
      "values": [1.0, 1.1, 0.9, ...]
    },
    {
      "id": "gene_r",
      "timestamps": [0.0, 1.0, 2.0, ...],
      "values": [0.8, 0.7, 0.9, ...]
    }
  ],
  "validation_type": "oscillation",           // Which validation to perform
  "expected_period_hours": 24.0,
  "tolerance_hours": 2.0
}
```

**Response (200 OK):**
```json
{
  "results": [
    {
      "signal_id": "gene_a",
      "validation_passed": true,
      "measured_period_hours": 24.3,
      "quality_score": 0.88
    },
    {
      "signal_id": "gene_r",
      "validation_passed": true,
      "measured_period_hours": 24.1,
      "quality_score": 0.85
    }
  ],
  "summary": {
    "total_signals": 2,
    "passed": 2,
    "failed": 0,
    "average_quality": 0.865
  },
  "metadata": {
    "computation_time_ms": 95
  }
}
```

---

## 🎛️ Parameter Tuning APIs

### Base Path: `/api/v1/tune`

---

### 12. Rate Constant Tuning

**Endpoint:** `POST /api/v1/tune/rate-constants`

**Description:** Optimize rate constants to fit observed time-series data. Supports biological constraints (organism-specific limits).

**Request Body:**
```json
{
  "observed_data": {
    "timestamps": [0.0, 1.0, 2.0, ...],
    "atp": [100, 105, 98, ...],
    "nadh": [50, 52, 48, ...]
  },
  "initial_rates": {
    "k_glycolysis": 0.5,
    "k_tca": 0.3,
    "k_oxphos": 0.7
  },
  "bounds": {
    "k_glycolysis": [0.1, 2.0],
    "k_tca": [0.05, 1.0],
    "k_oxphos": [0.2, 2.0]
  },
  "organism": "ecoli",                        // Apply E. coli constraints
  "optimization_method": "lbfgs",             // "lbfgs" | "nelder-mead" | "differential-evolution"
  "max_iterations": 1000
}
```

**Response (200 OK):**
```json
{
  "optimized_rates": {
    "k_glycolysis": 0.82,
    "k_tca": 0.45,
    "k_oxphos": 1.2
  },
  "fit_quality": 0.92,                        // 0-1 scale (R² or similar)
  "mse": 0.15,                                // Mean squared error
  "convergence": true,
  "iterations": 247,
  "constraints_satisfied": true,
  "constraint_violations": [],
  "metadata": {
    "computation_time_ms": 850,
    "optimization_method": "lbfgs",
    "organism": "ecoli"
  }
}
```

**Example Usage:**
```python
response = httpx.post(
    "http://bioxen.local:8000/api/v1/tune/rate-constants",
    json={
        "observed_data": {
            "timestamps": timestamps,
            "atp": atp_measurements
        },
        "initial_rates": {"k_glycolysis": 0.5, "k_tca": 0.3},
        "bounds": {"k_glycolysis": [0.1, 2.0], "k_tca": [0.05, 1.0]},
        "organism": "ecoli"
    }
)

data = response.json()
print(f"Optimized k_glycolysis: {data['optimized_rates']['k_glycolysis']:.2f}")
print(f"Fit quality: {data['fit_quality']:.1%}")
```

---

### 13. Timestep Optimization

**Endpoint:** `POST /api/v1/tune/timestep`

**Description:** Find optimal timestep for numerical simulation. Balances accuracy and computation time.

**Request Body:**
```json
{
  "observed_data": {
    "timestamps": [0.0, 1.0, 2.0, ...],
    "values": [1.0, 1.1, 0.9, ...]
  },
  "initial_timestep": 0.1,
  "target_accuracy": 1e-6,                    // Error tolerance
  "system_type": "stiff",                     // "stiff" | "non-stiff"
  "solver_hint": "implicit"                   // "implicit" | "explicit"
}
```

**Response (200 OK):**
```json
{
  "optimal_timestep": 0.01,
  "estimated_accuracy": 8.5e-7,
  "speedup_factor": 1.5,                      // Compared to initial timestep
  "stiffness_ratio": 100.5,                   // Ratio of fastest/slowest dynamics
  "recommendation": "Use implicit solver (Radau) with adaptive timestep",
  "metadata": {
    "computation_time_ms": 120
  }
}
```

---

### 14. Parameter Sweep

**Endpoint:** `POST /api/v1/tune/sweep`

**Description:** Perform 1D parameter sweep. Tests multiple parameter values and returns fitness scores.

**Request Body:**
```json
{
  "observed_data": {
    "timestamps": [0.0, 1.0, 2.0, ...],
    "values": [1.0, 1.1, 0.9, ...]
  },
  "parameter": "transcription_rate",
  "range": [0.1, 2.0],
  "num_points": 20,
  "fitness_metric": "mse"                     // "mse" | "r2" | "likelihood"
}
```

**Response (200 OK):**
```json
{
  "parameter_values": [0.1, 0.2, 0.3, ..., 2.0],
  "fit_scores": [0.45, 0.62, 0.75, ..., 0.50],
  "best_value": 0.85,
  "best_score": 0.92,
  "metadata": {
    "computation_time_ms": 450,
    "num_points": 20
  }
}
```

---

### 15. 2D Parameter Sweep

**Endpoint:** `POST /api/v1/tune/sweep-2d`

**Description:** Perform 2D parameter sweep (grid search). Returns heatmap data.

**Request Body:**
```json
{
  "observed_data": {
    "timestamps": [0.0, 1.0, 2.0, ...],
    "atp": [100, 105, 98, ...]
  },
  "parameters": {
    "k1": {"range": [0.1, 1.0], "num_points": 10},
    "k2": {"range": [0.2, 2.0], "num_points": 10}
  },
  "fitness_metric": "mse"
}
```

**Response (200 OK):**
```json
{
  "parameter_grid": {
    "k1": [0.1, 0.2, 0.3, ..., 1.0],
    "k2": [0.2, 0.4, 0.6, ..., 2.0]
  },
  "fit_scores": [                             // 10x10 grid
    [0.45, 0.50, 0.55, ..., 0.60],           // k1=0.1
    [0.50, 0.62, 0.70, ..., 0.65],           // k1=0.2
    ...
  ],
  "best_parameters": {
    "k1": 0.5,
    "k2": 1.2
  },
  "best_score": 0.92,
  "metadata": {
    "computation_time_ms": 2500,
    "grid_size": [10, 10]
  }
}
```

---

### 16. Sensitivity Analysis

**Endpoint:** `POST /api/v1/tune/sensitivity`

**Description:** Local sensitivity analysis. Compute gradients for each parameter.

**Request Body:**
```json
{
  "observed_data": {
    "timestamps": [0.0, 1.0, 2.0, ...],
    "values": [1.0, 1.1, 0.9, ...]
  },
  "parameters": {
    "k1": 0.5,
    "k2": 0.3,
    "k3": 0.2
  },
  "perturbation": 0.01                        // Percentage for finite differences
}
```

**Response (200 OK):**
```json
{
  "sensitivities": {
    "k1": 0.85,                               // High sensitivity
    "k2": 0.42,
    "k3": 0.15                                // Low sensitivity
  },
  "most_sensitive": "k1",
  "least_sensitive": "k3",
  "sensitivity_ranking": ["k1", "k2", "k3"],
  "metadata": {
    "computation_time_ms": 150
  }
}
```

---

### 17. Global Sensitivity Analysis

**Endpoint:** `POST /api/v1/tune/sensitivity-global`

**Description:** Global sensitivity analysis using Sobol indices. Accounts for parameter interactions.

**Request Body:**
```json
{
  "observed_data": {
    "timestamps": [0.0, 1.0, 2.0, ...],
    "atp": [100, 105, 98, ...]
  },
  "parameters": {
    "k_glycolysis": {"range": [0.1, 2.0]},
    "k_tca": {"range": [0.05, 1.0]},
    "k_oxphos": {"range": [0.2, 2.0]}
  },
  "method": "sobol",                          // "sobol" | "fast" | "morris"
  "num_samples": 1000
}
```

**Response (200 OK):**
```json
{
  "first_order_indices": {
    "k_glycolysis": 0.45,                     // Direct effect
    "k_tca": 0.25,
    "k_oxphos": 0.20
  },
  "total_order_indices": {
    "k_glycolysis": 0.65,                     // Direct + interactions
    "k_tca": 0.40,
    "k_oxphos": 0.35
  },
  "most_sensitive": "k_glycolysis",
  "interactions_detected": true,
  "metadata": {
    "computation_time_ms": 5000,
    "num_samples": 1000,
    "method": "sobol"
  }
}
```

---

### 18. Multi-Objective Optimization

**Endpoint:** `POST /api/v1/tune/multi-objective`

**Description:** Optimize multiple objectives simultaneously. Returns Pareto front.

**Request Body:**
```json
{
  "observed_data": {
    "timestamps": [0.0, 1.0, 2.0, ...],
    "atp": [100, 105, 98, ...]
  },
  "initial_rates": {
    "k1": 0.5,
    "k2": 0.3
  },
  "bounds": {
    "k1": [0.1, 2.0],
    "k2": [0.1, 2.0]
  },
  "objectives": [
    {"type": "fit_quality", "weight": 0.7},
    {"type": "parsimony", "weight": 0.3}      // Prefer simpler models
  ]
}
```

**Response (200 OK):**
```json
{
  "pareto_front": [
    {
      "parameters": {"k1": 0.82, "k2": 0.45},
      "objectives": {"fit_quality": 0.92, "parsimony": 0.75}
    },
    {
      "parameters": {"k1": 0.65, "k2": 0.38},
      "objectives": {"fit_quality": 0.88, "parsimony": 0.85}
    }
  ],
  "recommended_solution": {
    "parameters": {"k1": 0.82, "k2": 0.45},
    "reason": "Best trade-off between fit and parsimony"
  },
  "metadata": {
    "computation_time_ms": 3500,
    "pareto_points": 25
  }
}
```

---

## 🔌 Sensor Hardware APIs

### Base Path: `/api/v1/sensors`

---

### 19. Read BME280 Temperature

**Endpoint:** `GET /api/v1/sensors/bme280/temperature`

**Description:** Read current temperature from BME280 sensor.

**Response (200 OK):**
```json
{
  "temperature_celsius": 37.2,
  "sensor": "BME280",
  "timestamp": "2025-10-05T10:30:45Z",
  "calibrated": true,
  "metadata": {
    "read_time_ms": 15,
    "sensor_address": "0x76"
  }
}
```

---

### 20. Read BME280 Full Data

**Endpoint:** `GET /api/v1/sensors/bme280/all`

**Description:** Read temperature, pressure, and humidity from BME280.

**Response (200 OK):**
```json
{
  "temperature_celsius": 37.2,
  "pressure_hpa": 1013.25,
  "humidity_percent": 45.3,
  "sensor": "BME280",
  "timestamp": "2025-10-05T10:30:45Z",
  "calibrated": true,
  "metadata": {
    "read_time_ms": 20
  }
}
```

---

### 21. Read LTR-559 Light

**Endpoint:** `GET /api/v1/sensors/ltr559/light`

**Description:** Read light level from LTR-559 sensor.

**Response (200 OK):**
```json
{
  "light_lux": 150.5,
  "sensor": "LTR-559",
  "timestamp": "2025-10-05T10:30:45Z",
  "light_condition": "bright",                // "dark" | "dim" | "bright"
  "calibrated": true,
  "metadata": {
    "read_time_ms": 10,
    "gain": "1x",
    "integration_time_ms": 100
  }
}
```

---

### 22. Sensor Calibration

**Endpoint:** `POST /api/v1/sensors/{sensor_type}/calibrate`

**Description:** Calibrate sensor against known reference values.

**Path Parameters:**
- `sensor_type`: "bme280" | "ltr559"

**Request Body:**
```json
{
  "reference_value": 37.0,                    // Known reference (e.g., water bath temp)
  "num_samples": 10,                          // Number of samples for calibration
  "duration_seconds": 60                      // Time to collect samples
}
```

**Response (200 OK):**
```json
{
  "calibration_success": true,
  "offset": 0.2,                              // Calibration offset applied
  "std_dev": 0.05,                            // Measurement variability
  "samples_collected": 10,
  "metadata": {
    "calibration_time_ms": 60000,
    "timestamp": "2025-10-05T10:30:45Z"
  }
}
```

---

### 23. Sensor Status

**Endpoint:** `GET /api/v1/sensors/status`

**Description:** Check status of all connected sensors.

**Response (200 OK):**
```json
{
  "sensors": [
    {
      "type": "BME280",
      "address": "0x76",
      "status": "online",
      "last_read": "2025-10-05T10:30:45Z",
      "calibrated": true
    },
    {
      "type": "LTR-559",
      "address": "0x23",
      "status": "online",
      "last_read": "2025-10-05T10:30:40Z",
      "calibrated": true
    }
  ],
  "i2c_bus": 1,
  "metadata": {
    "check_time_ms": 25
  }
}
```

---

## ⚠️ Error Handling

### Error Response Format

All errors return a consistent JSON structure:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Timestamps and values must have the same length",
    "details": {
      "timestamps_length": 100,
      "values_length": 95
    },
    "timestamp": "2025-10-05T10:30:45Z"
  }
}
```

### HTTP Status Codes

| Code | Meaning | Use Case |
|------|---------|----------|
| 200 | OK | Successful request |
| 400 | Bad Request | Invalid input (empty arrays, wrong types) |
| 422 | Unprocessable Entity | Validation error (negative values, out of range) |
| 429 | Too Many Requests | Rate limit exceeded |
| 500 | Internal Server Error | Computation error, unexpected failure |
| 503 | Service Unavailable | Hardware sensor offline |

### Common Error Codes

| Error Code | Description | Example |
|------------|-------------|---------|
| `VALIDATION_ERROR` | Input validation failed | Arrays have different lengths |
| `COMPUTATION_ERROR` | Analysis failed | FFT computation error |
| `HARDWARE_ERROR` | Sensor read failed | I2C communication timeout |
| `CONSTRAINT_VIOLATION` | Biological constraint violated | Rate constant exceeds E. coli limits |
| `RATE_LIMIT_EXCEEDED` | Too many requests | More than 100 req/min |
| `TIMEOUT` | Computation timeout | Optimization took >30 seconds |

### Error Examples

**400 Bad Request:**
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Timestamps array cannot be empty",
    "timestamp": "2025-10-05T10:30:45Z"
  }
}
```

**422 Unprocessable Entity:**
```json
{
  "error": {
    "code": "CONSTRAINT_VIOLATION",
    "message": "Rate constant k_glycolysis exceeds E. coli maximum",
    "details": {
      "parameter": "k_glycolysis",
      "value": 5.0,
      "max_allowed": 2.0,
      "organism": "ecoli"
    }
  }
}
```

**500 Internal Server Error:**
```json
{
  "error": {
    "code": "COMPUTATION_ERROR",
    "message": "FFT computation failed: division by zero",
    "details": {
      "function": "fourier_lens",
      "stage": "power_spectrum_calculation"
    }
  }
}
```

**503 Service Unavailable:**
```json
{
  "error": {
    "code": "HARDWARE_ERROR",
    "message": "BME280 sensor not responding",
    "details": {
      "sensor": "BME280",
      "address": "0x76",
      "i2c_error": "timeout"
    }
  }
}
```

---

## 🚦 Rate Limiting

### Default Limits

- **Analysis endpoints:** 100 requests/minute per IP
- **Validation endpoints:** 200 requests/minute per IP
- **Tuning endpoints:** 20 requests/minute per IP (computationally expensive)
- **Sensor endpoints:** 1000 requests/minute per IP (fast reads)

### Rate Limit Headers

```http
HTTP/1.1 200 OK
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1696507845
```

### Rate Limit Exceeded

```json
{
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "Too many requests. Please try again later.",
    "details": {
      "limit": 100,
      "window": "1 minute",
      "retry_after": 45
    }
  }
}
```

---

## 🔧 Implementation Guide

### Phase 1: Analysis APIs (Week 1-2)

**Priority:** ⭐⭐⭐⭐⭐ (CRITICAL - Quick Win)

**Goal:** Wrap existing `SystemAnalyzer` in FastAPI endpoints.

**Files to Create:**
```
wishful-server/
├── api/
│   ├── __init__.py
│   ├── analysis.py          # Analysis endpoints
│   └── models.py            # Pydantic request/response models
├── core/
│   ├── __init__.py
│   └── analyzer_wrapper.py  # Wrap SystemAnalyzer
├── main.py                   # FastAPI app
└── requirements.txt
```

**Dependencies:**
```txt
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.4.2
numpy==1.24.3
scipy==1.11.3
astropy==5.3.4
PyWavelets==1.4.1
```

**Minimal Implementation:**
```python
# main.py
from fastapi import FastAPI
from api.analysis import router as analysis_router

app = FastAPI(
    title="BioXen Computation API",
    version="0.1.0",
    description="Remote computation services for biological signal analysis"
)

app.include_router(analysis_router, prefix="/api/v1/analysis", tags=["analysis"])

# api/analysis.py
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import List
import numpy as np
# Import from actual BioXen library
from bioxen_fourier_vm_lib.analysis.system_analyzer import SystemAnalyzer

router = APIRouter()
analyzer = SystemAnalyzer()

class FourierRequest(BaseModel):
    timestamps: List[float]
    values: List[float]
    method: str = "fft"
    detect_peaks: bool = False
    detect_harmonics: bool = False

@router.post("/fourier")
async def fourier_analysis(request: FourierRequest):
    try:
        result = analyzer.fourier_lens(
            time_series=np.array(request.values),
            timestamps=np.array(request.timestamps),
            detect_harmonics=request.detect_harmonics
        )
        return {
            "frequencies": result.frequencies.tolist(),
            "magnitudes": result.power_spectrum.tolist(),
            "phases": [0] * len(result.frequencies),  # TODO
            "dominant_frequency": result.dominant_frequency,
            "dominant_period": result.dominant_period,
            "significance": result.significance
        }
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

**Run Server:**
```bash
cd wishful-server
uvicorn main:app --host 0.0.0.0 --port 8000 --reload
```

**Test:**
```bash
curl -X POST http://localhost:8000/api/v1/analysis/fourier \
  -H "Content-Type: application/json" \
  -d '{"timestamps": [0,1,2,3,4], "values": [1.0, 1.1, 0.9, 1.05, 0.95]}'
```

---

### Phase 2: Validation Layer (Week 3-5)

**Priority:** ⭐⭐⭐⭐

**Goal:** Add validation policies around existing analysis.

**New Files:**
```
wishful-server/
├── api/
│   └── validation.py        # Validation endpoints
├── core/
│   ├── oscillation_validator.py
│   └── quality_scorer.py
```

**Implementation Pattern:**
```python
# core/oscillation_validator.py
class OscillationValidator:
    def __init__(self, analyzer: SystemAnalyzer):
        self.analyzer = analyzer
    
    def validate_period(self, timestamps, values, expected_period, tolerance):
        result = self.analyzer.fourier_lens(values, timestamps)
        measured = result.dominant_period
        deviation = abs(measured - expected_period)
        
        return {
            "measured_period_hours": measured,
            "validation_passed": deviation <= tolerance,
            "deviation_hours": deviation,
            "significance": result.significance
        }
```

---

### Phase 3: Optimization Framework (Week 6-11)

**Priority:** ⭐⭐⭐

**Goal:** Build parameter tuning with biological constraints.

**New Files:**
```
wishful-server/
├── api/
│   └── tuning.py            # Tuning endpoints
├── core/
│   ├── parameter_tuner.py
│   └── sensitivity_analyzer.py
```

**Additional Dependencies:**
```txt
SALib==1.4.7
scikit-optimize==0.9.0
```

---

### Phase 4: Hardware Integration (Week 12-15)

**Priority:** ⭐ (Optional)

**Goal:** Add sensor support.

**New Files:**
```
wishful-server/
├── api/
│   └── sensors.py           # Sensor endpoints
├── hardware/
│   ├── sensor_manager.py
│   ├── bme280_driver.py
│   └── ltr559_driver.py
```

**Additional Dependencies:**
```txt
smbus2==0.4.2
pimoroni-bme280==0.1.0
ltr559==0.1.0
```

---

## 🧪 Testing Strategy

### Run Wishful Tests

```bash
# After Phase 1
pytest wishful-client-tests/test_analysis.py -v
# Expected: 84% pass rate

# After Phase 2
pytest wishful-client-tests/test_validation.py -v
# Expected: 92% pass rate

# After Phase 3
pytest wishful-client-tests/test_tuning.py -v
# Expected: 72% pass rate

# After Phase 4
pytest wishful-client-tests/test_sensor_hardware.py -v
# Expected: 87% pass rate (with hardware)
```

---

## 📚 References

### BioXen Implementation
- `src/bioxen_fourier_vm_lib/analysis/system_analyzer.py` - Four-lens analysis
- `src/bioxen_fourier_vm_lib/genetics/circuits/optimization/bio_constraints.py` - Biological constraints
- `src/bioxen_fourier_vm_lib/hypervisor/core.py` - VM management (LOCAL ONLY)

### Test Suite
- `wishful-client-tests/test_analysis.py` - Analysis endpoint tests
- `wishful-client-tests/test_validation.py` - Validation endpoint tests
- `wishful-client-tests/test_tuning.py` - Optimization endpoint tests
- `wishful-client-tests/test_sensor_hardware.py` - Hardware integration tests

### Documentation
- `wishful-client-tests/COMPARISON_WITH_EXISTING_CODE.md` - Gap analysis
- `wishful-client-tests/CODE_MAPPING_DIAGRAM.md` - Visual mapping
- `wishful-client-tests/IMPLEMENTATION_ROADMAP.md` - Implementation plan

---

## 🚀 Quick Start

1. **Clone BioXen repository**
2. **Create wishful-server directory** (done ✅)
3. **Copy this specification** to `wishful-api-specification-document.md` (done ✅)
4. **Start with Phase 1** (Analysis APIs):
   ```bash
   cd wishful-server
   mkdir -p api core
   # Create main.py, api/analysis.py following Phase 1 guide
   pip install fastapi uvicorn numpy scipy astropy pywavelets
   uvicorn main:app --reload
   ```
5. **Test with curl or httpx**
6. **Run wishful-client-tests** to validate

---

**Version:** 0.1.0  
**Status:** Specification Complete ✅  
**Next Step:** Implement Phase 1 (Analysis APIs) 🚀
